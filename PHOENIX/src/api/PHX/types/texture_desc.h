#pragma once

#include "PHX/types/integral_types.h"

namespace PHX
{
	enum class VIEW_SCOPE
	{
		INVALID = 0,

		ENTIRE, // Generates an image view for the entire image, including all mip levels and cubemap faces (in cases where image is a cubemap)
		PER_MIP	// Generates an image view for every mip level
	};

	enum class FILTER_MODE
	{
		INVALID = 0,

		NEAREST,
		LINEAR
	};

	enum class SAMPLER_ADDRESS_MODE
	{
		INVALID = 0,

		REPEAT,
		MIRRORED_REPEAT,
		CLAMP_TO_EDGE,
		CLAMP_TO_BORDER,
		MIRRORED_CLAMP_TO_EDGE
	};

	enum class USAGE_TYPE : u16
	{
		INVALID = 0,

		TRANSFER_SRC,
		TRANSFER_DST,
		SAMPLED,
		STORAGE,
		COLOR_ATTACHMENT,
		DEPTH_STENCIL_ATTACHMENT,
		TRANSIENT_ATTACHMENT,
		INPUT_ATTACHMENT,

		MAX      // Do not use - must come last
	};

	enum USAGE_TYPE_FLAG : u16
	{
		USAGE_TYPE_FLAG_INVALID                  = (1 << static_cast<u8>(USAGE_TYPE::INVALID)),

		USAGE_TYPE_FLAG_TRANSFER_SRC             = (1 << static_cast<u8>(USAGE_TYPE::TRANSFER_SRC)),
		USAGE_TYPE_FLAG_TRANSFER_DST             = (1 << static_cast<u8>(USAGE_TYPE::TRANSFER_DST)),
		USAGE_TYPE_FLAG_SAMPLED                  = (1 << static_cast<u8>(USAGE_TYPE::SAMPLED)),
		USAGE_TYPE_FLAG_STORAGE                  = (1 << static_cast<u8>(USAGE_TYPE::STORAGE)),
		USAGE_TYPE_FLAG_COLOR_ATTACHMENT         = (1 << static_cast<u8>(USAGE_TYPE::COLOR_ATTACHMENT)),
		USAGE_TYPE_FLAG_DEPTH_STENCIL_ATTACHMENT = (1 << static_cast<u8>(USAGE_TYPE::DEPTH_STENCIL_ATTACHMENT)),
		USAGE_TYPE_FLAG_TRANSIENT_ATTACHMENT     = (1 << static_cast<u8>(USAGE_TYPE::TRANSIENT_ATTACHMENT)),
		USAGE_TYPE_FLAG_INPUT_ATTACHMENT         = (1 << static_cast<u8>(USAGE_TYPE::INPUT_ATTACHMENT)),
	};
	using UsageTypeFlags = u16;

	enum class SAMPLE_COUNT : u8
	{
		INVALID = 0,

		COUNT_1,
		COUNT_2,
		COUNT_4,
		COUNT_8,
		COUNT_16,
		COUNT_32,
		COUNT_64,

		MAX        // Do not use - must come last
	};

	enum class VIEW_TYPE
	{
		INVALID = 0,

		TYPE_1D,
		TYPE_2D,
		TYPE_3D,
		TYPE_CUBE,
		TYPE_1D_ARRAY,
		TYPE_2D_ARRAY,
		TYPE_CUBE_ARRAY
	};

	enum class ASPECT_TYPE : u8
	{
		INVALID = 0,

		COLOR,
		DEPTH,
		STENCIL,

		MAX      // Do not use - must come last
	};

	enum ASPECT_TYPE_FLAG : u8
	{
		ASPECT_TYPE_FLAG_INVALID = (1 << static_cast<u8>(ASPECT_TYPE::INVALID)),

		ASPECT_TYPE_FLAG_COLOR   = (1 << static_cast<u8>(ASPECT_TYPE::COLOR)),
		ASPECT_TYPE_FLAG_DEPTH   = (1 << static_cast<u8>(ASPECT_TYPE::DEPTH)),
		ASPECT_TYPE_FLAG_STENCIL = (1 << static_cast<u8>(ASPECT_TYPE::STENCIL))
	};
	using AspectTypeFlags = u8;

	enum class BASE_FORMAT
	{
		INVALID = 0,

		// 8-bit component RGBA
		R8_UNORM,
		R8_SNORM,
		R8_UINT,
		R8_SINT,
		R8_SRGB,
		R8G8_UNORM,
		R8G8_SNORM,
		R8G8_UINT,
		R8G8_SINT,
		R8G8_SRGB,
		R8G8B8_UNORM,
		R8G8B8_SNORM,
		R8G8B8_UINT,
		R8G8B8_SINT,
		R8G8B8_SRGB,
		R8G8B8A8_UNORM,
		R8G8B8A8_SNORM,
		R8G8B8A8_UINT,
		R8G8B8A8_SINT,
		R8G8B8A8_SRGB,

		// 16-bit component RGBA
		R16_UNORM,
		R16_SNORM,
		R16_UINT,
		R16_SINT,
		R16_FLOAT,
		R16G16_UNORM,
		R16G16_SNORM,
		R16G16_UINT,
		R16G16_SINT,
		R16G16_FLOAT,
		R16G16B16_UNORM,
		R16G16B16_SNORM,
		R16G16B16_UINT,
		R16G16B16_SINT,
		R16G16B16_FLOAT,
		R16G16B16A16_UNORM,
		R16G16B16A16_SNORM,
		R16G16B16A16_UINT,
		R16G16B16A16_SINT,
		R16G16B16A16_FLOAT,

		// 32-bit component RGBA
		R32_UINT,
		R32_SINT,
		R32_FLOAT,
		R32G32_UINT,
		R32G32_SINT,
		R32G32_FLOAT,
		R32G32B32_UINT,
		R32G32B32_SINT,
		R32G32B32_FLOAT,
		R32G32B32A32_UINT,
		R32G32B32A32_SINT,
		R32G32B32A32_FLOAT,

		// 64-bit component RGBA
		R64_UINT,
		R64_SINT,
		R64_FLOAT,
		R64G64_UINT,
		R64G64_SINT,
		R64G64_FLOAT,
		R64G64B64_UINT,
		R64G64B64_SINT,
		R64G64B64_FLOAT,
		R64G64B64A64_UINT,
		R64G64B64A64_SINT,
		R64G64B64A64_FLOAT,
		
		// Depth / stencil
		D16_UNORM,
		D32_FLOAT,
		S8_UINT,
		D16_UNORM_S8_UINT,
		D24_UNORM_S8_UINT,
		D32_FLOAT_S8_UINT,

		// Surface formats
		B8G8R8A8_SRGB
	};
}